import{_ as e,c as i,o as r,ag as t}from"./chunks/framework.DPDPlp3K.js";const b=JSON.parse('{"title":"设计模式","description":"","frontmatter":{"title":"设计模式","date":"2020-01-01T09:02:55.000Z","categories":["技巧"],"tags":["技巧"],"sidebar":"heading"},"headers":[],"relativePath":"notes/be/tech-stack/design-pattern.md","filePath":"notes/be/tech-stack/design-pattern.md"}'),o={name:"notes/be/tech-stack/design-pattern.md"};function l(n,a,h,p,s,c){return r(),i("div",null,a[0]||(a[0]=[t('<h1 id="_0、uml" tabindex="-1">0、UML <a class="header-anchor" href="#_0、uml" aria-label="Permalink to &quot;0、UML&quot;">​</a></h1><p><img src="https://raw.githubusercontent.com/alooc/images/main/blog/1679451590308-007a8ca7-908b-4625-a742-4b294844180.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/alooc/images/main/blog/1679451610891-0cb9e106-3e35-407f-a06b-436aaf070f5e.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/alooc/images/main/blog/1679451625291-8c35fbcf-ee20-4051-b416-7c6c8997bdca.png" alt="img"></p><p>依赖 a的方法参数使用b，程序员使用电脑</p><p>关联 a的变量是b,张三是学生，张三的老师是李四</p><p>聚合 学校和老师，关系弱，老师可独立使用</p><p>组合 人体和大脑，关系强，大脑不独立使用</p><p>实现 实现接口</p><p>继承 继承父类</p><h1 id="_1、设计原则" tabindex="-1">1、设计原则 <a class="header-anchor" href="#_1、设计原则" aria-label="Permalink to &quot;1、设计原则&quot;">​</a></h1><h3 id="_1、封装变化的内容" tabindex="-1">1、封装变化的内容 <a class="header-anchor" href="#_1、封装变化的内容" aria-label="Permalink to &quot;1、封装变化的内容&quot;">​</a></h3><p>找到程序中变化的内容并将其与不变的内容区分开</p><ol><li><ol><li>方法层面的封装</li><li>类层面的封装</li></ol></li></ol><h3 id="_2、面向接口开发-而不是面向实现【接口隔离原则】" tabindex="-1">2、面向接口开发，而不是面向实现【接口隔离原则】 <a class="header-anchor" href="#_2、面向接口开发-而不是面向实现【接口隔离原则】" aria-label="Permalink to &quot;2、面向接口开发，而不是面向实现【接口隔离原则】&quot;">​</a></h3><p>面向接口开发，而不是实现；依赖于抽象类型，而不是具体类</p><h3 id="_3、组合优于继承【组合复用原则】" tabindex="-1">3、组合优于继承【组合复用原则】 <a class="header-anchor" href="#_3、组合优于继承【组合复用原则】" aria-label="Permalink to &quot;3、组合优于继承【组合复用原则】&quot;">​</a></h3><h3 id="_4、solid原则" tabindex="-1">4、SOLID原则 <a class="header-anchor" href="#_4、solid原则" aria-label="Permalink to &quot;4、SOLID原则&quot;">​</a></h3><h4 id="single-responsibility-principle-单一职责原则-修改一个类的原因只有一个。" tabindex="-1">single responsibility principle 单一职责原则：修改一个类的原因只有一个。 <a class="header-anchor" href="#single-responsibility-principle-单一职责原则-修改一个类的原因只有一个。" aria-label="Permalink to &quot;single responsibility principle 单一职责原则：修改一个类的原因只有一个。&quot;">​</a></h4><h4 id="open-closed-principle-开闭原则-对于扩展-类是开放的-对于修改-类是封闭的。实现新功能时保持已有功能不变。" tabindex="-1">open/closed principle 开闭原则：对于扩展，类是开放的；对于修改，类是封闭的。实现新功能时保持已有功能不变。 <a class="header-anchor" href="#open-closed-principle-开闭原则-对于扩展-类是开放的-对于修改-类是封闭的。实现新功能时保持已有功能不变。" aria-label="Permalink to &quot;open/closed principle 开闭原则：对于扩展，类是开放的；对于修改，类是封闭的。实现新功能时保持已有功能不变。&quot;">​</a></h4><h4 id="liskov-substitution-principle-里氏替换原则-当扩展一个类时-应该在不修改客户端代码的情况下将子类对象作为父类对象传递。" tabindex="-1">liskov substitution principle 里氏替换原则：当扩展一个类时，应该在不修改客户端代码的情况下将子类对象作为父类对象传递。 <a class="header-anchor" href="#liskov-substitution-principle-里氏替换原则-当扩展一个类时-应该在不修改客户端代码的情况下将子类对象作为父类对象传递。" aria-label="Permalink to &quot;liskov substitution principle 里氏替换原则：当扩展一个类时，应该在不修改客户端代码的情况下将子类对象作为父类对象传递。&quot;">​</a></h4><h4 id="interface-segregation-principle-接口隔离原则-客户端不应被强迫依赖其不使用的方法。" tabindex="-1">interface segregation principle 接口隔离原则：客户端不应被强迫依赖其不使用的方法。 <a class="header-anchor" href="#interface-segregation-principle-接口隔离原则-客户端不应被强迫依赖其不使用的方法。" aria-label="Permalink to &quot;interface segregation principle 接口隔离原则：客户端不应被强迫依赖其不使用的方法。&quot;">​</a></h4><h4 id="dependency-inversion-principle-依赖倒置原则-高层次的类不应该依赖于低层次的类。两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽象接口。" tabindex="-1">dependency inversion principle 依赖倒置原则：高层次的类不应该依赖于低层次的类。两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽象接口。 <a class="header-anchor" href="#dependency-inversion-principle-依赖倒置原则-高层次的类不应该依赖于低层次的类。两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽象接口。" aria-label="Permalink to &quot;dependency inversion principle 依赖倒置原则：高层次的类不应该依赖于低层次的类。两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽象接口。&quot;">​</a></h4><h1 id="_2、设计模式" tabindex="-1">2、设计模式 <a class="header-anchor" href="#_2、设计模式" aria-label="Permalink to &quot;2、设计模式&quot;">​</a></h1><h2 id="_1、创建型模式" tabindex="-1">1、创建型模式 <a class="header-anchor" href="#_1、创建型模式" aria-label="Permalink to &quot;1、创建型模式&quot;">​</a></h2><p>提供了创建对象的机制，能够提升已有代码的灵活性和可复用性。</p><h3 id="_1、工厂方法" tabindex="-1">1、工厂方法 <a class="header-anchor" href="#_1、工厂方法" aria-label="Permalink to &quot;1、工厂方法&quot;">​</a></h3><p>在父类中提供一个创建对象的接口以允许子类决定实例化对象的类型。</p><p>工厂方法模式包含以下角色：</p><ol><li><strong>抽象产品（Product）</strong>：定义了产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的模板。</li><li><strong>具体产品（Concrete Product）</strong>：实现了抽象产品接口，是工厂方法模式所创建的具体对象。</li><li><strong>抽象工厂（Creator）</strong>：定义了工厂方法的接口，负责返回一个合适的产品对象。</li><li><strong>具体工厂（Concrete Creator）</strong>：实现了抽象工厂接口，负责实例化具体产品对象。</li></ol><h3 id="_2、抽象工厂" tabindex="-1">2、抽象工厂 <a class="header-anchor" href="#_2、抽象工厂" aria-label="Permalink to &quot;2、抽象工厂&quot;">​</a></h3><p>创建一系列相关的类，而无需指定其具体的类</p><p>工厂的工厂； 一个将单个但相关/从属的工厂分组在一起而没有指定其具体类别的工厂。</p><p>与工厂方法的区别：工厂方法是单一的工厂，抽象工厂是全面工厂，更加抽象。</p><h3 id="_3、生成器" tabindex="-1">3、生成器 <a class="header-anchor" href="#_3、生成器" aria-label="Permalink to &quot;3、生成器&quot;">​</a></h3><p>分步骤创建复杂对象。使用相同的创建代码生成不同类型和形式的对象。</p><h3 id="_4、原型" tabindex="-1">4、原型 <a class="header-anchor" href="#_4、原型" aria-label="Permalink to &quot;4、原型&quot;">​</a></h3><p>复制已有对象，而又无需代码依赖他们所属的类。</p><h3 id="_5、单例" tabindex="-1">5、单例 <a class="header-anchor" href="#_5、单例" aria-label="Permalink to &quot;5、单例&quot;">​</a></h3><p>保证一个类只有一个实例，并提供一个访问该实例的全局节点。</p><p>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供对该实例的全局访问点。这意味着当您创建一个对象时，无论何时都只能创建一个实例，而该实例将在应用程序中的所有代码中使用。</p><p>单例模式通常用于管理共享资源，例如数据库连接或文件系统对象。在这些情况下，多个实例可能会导致资源争用或意外的行为。</p><h2 id="_2、结构型模式" tabindex="-1">2、结构型模式 <a class="header-anchor" href="#_2、结构型模式" aria-label="Permalink to &quot;2、结构型模式&quot;">​</a></h2><p>结构型模式介绍如何将对象和组装成较大的结构，并同时保持结构的灵活和高效。</p><h3 id="_1、适配器" tabindex="-1">1、适配器 <a class="header-anchor" href="#_1、适配器" aria-label="Permalink to &quot;1、适配器&quot;">​</a></h3><p>使接口不兼容的对象可以相互合作。</p><p>适配器模式把不兼容的对象包在适配器中，以让其兼容其他类。</p><h3 id="_2、桥接" tabindex="-1">2、桥接 <a class="header-anchor" href="#_2、桥接" aria-label="Permalink to &quot;2、桥接&quot;">​</a></h3><p>将一个大类或一系列紧密相关的类拆分成抽象和实现两个独立的层次结构，从而能在开发时分别使用。</p><p>将抽象与实现分离，以便二者可以独立变化</p><h3 id="_3、组合" tabindex="-1">3、组合 <a class="header-anchor" href="#_3、组合" aria-label="Permalink to &quot;3、组合&quot;">​</a></h3><p>将对象组合成树状结构，并且能够像使用独立对象一样使用他们。</p><h3 id="_4、装饰" tabindex="-1">4、装饰 <a class="header-anchor" href="#_4、装饰" aria-label="Permalink to &quot;4、装饰&quot;">​</a></h3><p>将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。</p><h3 id="_5、外观" tabindex="-1">5、外观 <a class="header-anchor" href="#_5、外观" aria-label="Permalink to &quot;5、外观&quot;">​</a></h3><p>为程序库、框架或其他复杂类提供一个简单的接口。</p><h3 id="_6、享元" tabindex="-1">6、享元 <a class="header-anchor" href="#_6、享元" aria-label="Permalink to &quot;6、享元&quot;">​</a></h3><p>摒弃在每个对象中保存所有数据的方式，通过共享多个对象所共有的相同状态，在有限的内存容量内载入更多的对象。</p><h3 id="_7、代理" tabindex="-1">7、代理 <a class="header-anchor" href="#_7、代理" aria-label="Permalink to &quot;7、代理&quot;">​</a></h3><p>可以提供对象的替代品或其占位符。代理控制着对于原对象的访问，并可以在把请求提交给对象的前后进行一些处理。</p><h2 id="_3、行为模式" tabindex="-1">3、行为模式 <a class="header-anchor" href="#_3、行为模式" aria-label="Permalink to &quot;3、行为模式&quot;">​</a></h2><p>负责对象间的高效沟通和职责委派。</p><h3 id="_1、责任链" tabindex="-1">1、责任链 <a class="header-anchor" href="#_1、责任链" aria-label="Permalink to &quot;1、责任链&quot;">​</a></h3><p>允许将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。</p><h3 id="_2、命令" tabindex="-1">2、命令 <a class="header-anchor" href="#_2、命令" aria-label="Permalink to &quot;2、命令&quot;">​</a></h3><p>将请求封装成对象，从而使你可以将不同的请求的客户端参数化，队列或记录请求，并且支持可撤销操作。</p><p>用命令对象的方式存储请求以在将来可以执行或撤销它。</p><h3 id="_3、迭代器" tabindex="-1">3、迭代器 <a class="header-anchor" href="#_3、迭代器" aria-label="Permalink to &quot;3、迭代器&quot;">​</a></h3><p>在不暴露集合底层表现形式（列表、栈和树等）的情况下遍历集合中所有的元素。</p><p>提供一种在不暴露其基础表示的情况下顺序访问聚合对象的元素的方法。</p><p>容器可以提供与表示形式无关的迭代器接口，以提供对元素的访问。</p><h3 id="_4、中介者" tabindex="-1">4、中介者 <a class="header-anchor" href="#_4、中介者" aria-label="Permalink to &quot;4、中介者&quot;">​</a></h3><p>减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使他们通过一个中介者对象进行合作。</p><h3 id="_5、备忘录" tabindex="-1">5、备忘录 <a class="header-anchor" href="#_5、备忘录" aria-label="Permalink to &quot;5、备忘录&quot;">​</a></h3><p>在不暴露对象实现细节的情况下保存和恢复对象之前的状态。</p><h3 id="_6、观察者" tabindex="-1">6、观察者 <a class="header-anchor" href="#_6、观察者" aria-label="Permalink to &quot;6、观察者&quot;">​</a></h3><p>允许定义一种订阅机制 ， 可在对象事件发生时通知多个观察该对象的其他对象。</p><p>目的：定义一种一对多的依赖关系，这样当一个对象改变状态时，所有依赖它的对象都将自动通知或更新。</p><h3 id="_7、状态" tabindex="-1">7、状态 <a class="header-anchor" href="#_7、状态" aria-label="Permalink to &quot;7、状态&quot;">​</a></h3><p>在一个对象内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样。</p><p>状态模式与有限状态机紧密相关。</p><h3 id="_8、策略" tabindex="-1">8、策略 <a class="header-anchor" href="#_8、策略" aria-label="Permalink to &quot;8、策略&quot;">​</a></h3><p>定义一系列的算法，并将每种算法分别放入独立的类中，以使算法的对象可以互换。</p><h3 id="_9、模板方法" tabindex="-1">9、模板方法 <a class="header-anchor" href="#_9、模板方法" aria-label="Permalink to &quot;9、模板方法&quot;">​</a></h3><p>在超类中定义一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。</p><h3 id="_10、访问者" tabindex="-1">10、访问者 <a class="header-anchor" href="#_10、访问者" aria-label="Permalink to &quot;10、访问者&quot;">​</a></h3><p>将算法与其所作用的对象隔离开来。</p>',87)]))}const u=e(o,[["render",l]]);export{b as __pageData,u as default};
