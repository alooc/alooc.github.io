const e=JSON.parse('{"key":"v-2db914b0","path":"/blog/algorithm/base/1%E3%80%81%E7%AE%97%E6%B3%95%E6%8C%87%E6%A0%87%E5%8F%8A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html","title":"1、算法指标及排序算法","lang":"zh-CN","frontmatter":{"title":"1、算法指标及排序算法","sidebar":"heading","category":["算法"],"tag":"算法","description":"一、衡量算法的指标 1. 时间复杂度 大致估计算法执行时间的量级。 master公式计算递归复杂度，只适用于子问题规模一致，用到时直接百度公式 2. 空间复杂度 大致估计算法执行所需内存空间的量级 3. 对数器 使用最笨方法实现一个最基本的算法，作为对数器，来校验算法是否正确。 二、排序算法 1. 如何分类 a. 是否基于元素之间的比较进行排序 - 基于比较的排序：插入、冒泡、归并等 - 不基于比较的排序：桶排序，基数排序","head":[["meta",{"property":"og:url","content":"https://alooc.github.io/blog/algorithm/base/1%E3%80%81%E7%AE%97%E6%B3%95%E6%8C%87%E6%A0%87%E5%8F%8A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Alooc"}],["meta",{"property":"og:title","content":"1、算法指标及排序算法"}],["meta",{"property":"og:description","content":"一、衡量算法的指标 1. 时间复杂度 大致估计算法执行时间的量级。 master公式计算递归复杂度，只适用于子问题规模一致，用到时直接百度公式 2. 空间复杂度 大致估计算法执行所需内存空间的量级 3. 对数器 使用最笨方法实现一个最基本的算法，作为对数器，来校验算法是否正确。 二、排序算法 1. 如何分类 a. 是否基于元素之间的比较进行排序 - 基于比较的排序：插入、冒泡、归并等 - 不基于比较的排序：桶排序，基数排序"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-20T16:15:20.000Z"}],["meta",{"property":"article:author","content":"Alooc"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:modified_time","content":"2024-09-20T16:15:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"1、算法指标及排序算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-09-20T16:15:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Alooc\\",\\"url\\":\\"https://alooc.github.io\\"}]}"]]},"headers":[{"level":2,"title":"1. 时间复杂度","slug":"_1-时间复杂度","link":"#_1-时间复杂度","children":[]},{"level":2,"title":"2. 空间复杂度","slug":"_2-空间复杂度","link":"#_2-空间复杂度","children":[]},{"level":2,"title":"3. 对数器","slug":"_3-对数器","link":"#_3-对数器","children":[]},{"level":2,"title":"1. 如何分类","slug":"_1-如何分类","link":"#_1-如何分类","children":[{"level":3,"title":"a. 是否基于元素之间的比较进行排序","slug":"a-是否基于元素之间的比较进行排序","link":"#a-是否基于元素之间的比较进行排序","children":[]},{"level":3,"title":"b. 排序后是否稳定【排序后相等元素仍保持其原有顺序】","slug":"b-排序后是否稳定【排序后相等元素仍保持其原有顺序】","link":"#b-排序后是否稳定【排序后相等元素仍保持其原有顺序】","children":[]},{"level":3,"title":"c. 排序时间复杂度是否线性【排序时间复杂度的类型，线性，指数型】","slug":"c-排序时间复杂度是否线性【排序时间复杂度的类型-线性-指数型】","link":"#c-排序时间复杂度是否线性【排序时间复杂度的类型-线性-指数型】","children":[]},{"level":3,"title":"d. 是否需要额外的内存空间","slug":"d-是否需要额外的内存空间","link":"#d-是否需要额外的内存空间","children":[]}]},{"level":2,"title":"2. 排序算法","slug":"_2-排序算法","link":"#_2-排序算法","children":[{"level":3,"title":"0. 排序是什么","slug":"_0-排序是什么","link":"#_0-排序是什么","children":[]},{"level":3,"title":"1. 选择排序","slug":"_1-选择排序","link":"#_1-选择排序","children":[]},{"level":3,"title":"2. 插入排序","slug":"_2-插入排序","link":"#_2-插入排序","children":[]},{"level":3,"title":"3. 冒泡排序","slug":"_3-冒泡排序","link":"#_3-冒泡排序","children":[]},{"level":3,"title":"4. 归并排序","slug":"_4-归并排序","link":"#_4-归并排序","children":[]},{"level":3,"title":"5. 快速排序","slug":"_5-快速排序","link":"#_5-快速排序","children":[]},{"level":3,"title":"6. 堆排序","slug":"_6-堆排序","link":"#_6-堆排序","children":[]},{"level":3,"title":"7. 桶排序","slug":"_7-桶排序","link":"#_7-桶排序","children":[]},{"level":3,"title":"8. 计数排序","slug":"_8-计数排序","link":"#_8-计数排序","children":[]},{"level":3,"title":"9. 基数排序","slug":"_9-基数排序","link":"#_9-基数排序","children":[]},{"level":3,"title":"10. 希尔排序","slug":"_10-希尔排序","link":"#_10-希尔排序","children":[]}]}],"git":{"createdTime":1726848920000,"updatedTime":1726848920000,"contributors":[{"name":"alooc","email":"zbsx508@gmail.com","commits":1}]},"readingTime":{"minutes":7.77,"words":2331},"filePathRelative":"blog/algorithm/base/1、算法指标及排序算法.md","localizedDate":"2024年9月20日","excerpt":"<h1> 一、衡量算法的指标</h1>\\n<h2> 1. 时间复杂度</h2>\\n<p>大致估计算法执行时间的量级。</p>\\n<blockquote>\\n<p>master公式计算递归复杂度，只适用于子问题规模一致，用到时直接百度公式</p>\\n</blockquote>\\n<h2> 2. 空间复杂度</h2>\\n<p>大致估计算法执行所需内存空间的量级</p>\\n<h2> 3. 对数器</h2>\\n<p>使用最笨方法实现一个最基本的算法，作为对数器，来校验算法是否正确。</p>\\n<h1> 二、排序算法</h1>\\n<h2> 1. 如何分类</h2>\\n<h3> a. 是否基于元素之间的比较进行排序</h3>\\n<pre><code>- 基于比较的排序：插入、冒泡、归并等\\n- 不基于比较的排序：桶排序，基数排序\\n</code></pre>","autoDesc":true}');export{e as data};
