import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as e,b as d}from"./app-64e721bb.js";const r={},h=d('<h1 id="前置概念了解" tabindex="-1"><a class="header-anchor" href="#前置概念了解" aria-hidden="true">#</a> 前置概念了解：</h1><h3 id="什么是amqp-和-jms" tabindex="-1"><a class="header-anchor" href="#什么是amqp-和-jms" aria-hidden="true">#</a> 什么是AMQP 和 JMS？</h3><p><strong>AMQP</strong>：即Advanced Message Queuing Protocol，是一个应用层标准高级消息队列协议，提供统一消息服务。是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。<strong>Erlang中的实现有RabbitMQ</strong>等。</p><p><strong>JMS</strong>：即Java消息服务（Java Message Service）<strong>应用程序接口</strong>，由sun公司提出，并且sun公司定义好了接口。包括create、send、recieve。只要想使用它，就得实现它定义的接口。 消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。不好的地方是语言层面的限制，只能为JAVA，这其实稍微有点和微服务的观点相违背。要求语言只能是JAVA，而不能是py等。</p><h3 id="常见的mq产品" tabindex="-1"><a class="header-anchor" href="#常见的mq产品" aria-hidden="true">#</a> 常见的MQ产品</h3><p>ActiveMQ：基于JMS，Apache</p><p>RocketMQ：（Rocket，火箭）阿里巴巴的产品，基于JMS，目前由Apache基于会维护</p><p>Kafka：分布式消息系统，亮点：吞吐量超级高，没秒中数十万的并发。</p><p>RabbitMQ：（Rabbit，兔子）由erlang语言开发，基于AMQP协议，在erlang语言特性的加持下，RabbitMQ稳定性要比其他的MQ产品好一些，而且erlang语言本身是面向高并发的编程的语言，所以RabbitMQ速度也非常快。且它基于AMQP协议，对分布式、微服务更友好。</p><h1 id="基础概念" tabindex="-1"><a class="header-anchor" href="#基础概念" aria-hidden="true">#</a> 基础概念</h1><table><thead><tr><th>中文名</th><th>英文名</th><th>描述</th></tr></thead><tbody><tr><td>生产者</td><td>Producer</td><td>消息的发送者，可以将消息发送到交换机</td></tr><tr><td>消费者</td><td>Consumer</td><td>消息的接收者，从队列中获取消息并进行消费</td></tr><tr><td>交换机</td><td>Exchange</td><td>接收生产者发送的消息，并根据路由键发送给指定队列</td></tr><tr><td>队列</td><td>Queue</td><td>存储从交换机发来的消息</td></tr><tr><td>交换机类型</td><td>type</td><td>不同类型的交换机转发消息方式不同</td></tr><tr><td>发布/订阅模式</td><td>fanout</td><td>广播消息给所有绑定交换机的队列</td></tr><tr><td>路由模式</td><td>direct</td><td>根据路由键发送消息</td></tr><tr><td>通配符模式</td><td>topic</td><td>根据路由键的匹配规则发送消息</td></tr></tbody></table><h1 id="_5种消息模式" tabindex="-1"><a class="header-anchor" href="#_5种消息模式" aria-hidden="true">#</a> 5种消息模式：</h1><h2 id="_1、简单模式" tabindex="-1"><a class="header-anchor" href="#_1、简单模式" aria-hidden="true">#</a> 1、简单模式</h2><p>一个生产者、一个消费者</p><h2 id="_2、工作模式" tabindex="-1"><a class="header-anchor" href="#_2、工作模式" aria-hidden="true">#</a> 2、工作模式</h2><p>一个生产者、多个消费者，消费者之间竞争消费</p><h2 id="_3、发布-订阅模式" tabindex="-1"><a class="header-anchor" href="#_3、发布-订阅模式" aria-hidden="true">#</a> 3、发布/订阅模式</h2><p>一个生产者，一个转换机，多个消费者。转换机绑定队列，消费者仅消费订阅的队列消息</p><h2 id="_4、路由模式" tabindex="-1"><a class="header-anchor" href="#_4、路由模式" aria-hidden="true">#</a> 4、路由模式</h2><p>一个生产者，一个转换机，多个消费者。转换机根据key绑定队列</p><h2 id="_5、通配符模式" tabindex="-1"><a class="header-anchor" href="#_5、通配符模式" aria-hidden="true">#</a> 5、通配符模式</h2><p>一个生产者，一个转换机，多个消费者。转换机根据key值匹配绑定队列</p><blockquote><p>中间件、框架入门很简单，深入原理需理解源码。</p></blockquote>',23),n=[h];function i(c,s){return a(),e("div",null,n)}const b=t(r,[["render",i],["__file","rabbitmq.html.vue"]]);export{b as default};
