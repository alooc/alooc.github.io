const e=JSON.parse('{"key":"v-0f87f09a","path":"/blog/old/language/java/JUC.html","title":"JUC","lang":"zh-CN","frontmatter":{"title":"JUC","date":"2020-01-01T09:02:55.000Z","category":["编程语言","Java"],"tag":["Java"],"description":"1. 概念 JUC: java.utl.concrrent 进程和线程 wait和sleep 并发和并行 管程 Monitor监视器，也称锁，是一种同步机制，保证同一时间，只有一个线程访问被保护数据或代码 JVM同步资源的进入和退出，是用管程对象实现的 用户线程和守护线程： 自定义线程， 后台的线程，比如垃圾回收 主线程结束，自定义线程仍在，如果没有用户线程，只有守护线程，JVM结束","head":[["meta",{"property":"og:url","content":"https://alooc.github.io/blog/old/language/java/JUC.html"}],["meta",{"property":"og:site_name","content":"Alooc"}],["meta",{"property":"og:title","content":"JUC"}],["meta",{"property":"og:description","content":"1. 概念 JUC: java.utl.concrrent 进程和线程 wait和sleep 并发和并行 管程 Monitor监视器，也称锁，是一种同步机制，保证同一时间，只有一个线程访问被保护数据或代码 JVM同步资源的进入和退出，是用管程对象实现的 用户线程和守护线程： 自定义线程， 后台的线程，比如垃圾回收 主线程结束，自定义线程仍在，如果没有用户线程，只有守护线程，JVM结束"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-22T01:58:54.000Z"}],["meta",{"property":"article:author","content":"Alooc"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2020-01-01T09:02:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-22T01:58:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JUC\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-01-01T09:02:55.000Z\\",\\"dateModified\\":\\"2024-04-22T01:58:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Alooc\\",\\"url\\":\\"https://alooc.github.io\\"}]}"]]},"headers":[{"level":2,"title":"synchronized八种类型的锁：","slug":"synchronized八种类型的锁","link":"#synchronized八种类型的锁","children":[]},{"level":2,"title":"可重入锁","slug":"可重入锁","link":"#可重入锁","children":[]},{"level":2,"title":"死锁","slug":"死锁","link":"#死锁","children":[]},{"level":2,"title":"1. CountDownLatch 减少计数","slug":"_1-countdownlatch-减少计数","link":"#_1-countdownlatch-减少计数","children":[]},{"level":2,"title":"2. CyclicBarrier 循环栅栏","slug":"_2-cyclicbarrier-循环栅栏","link":"#_2-cyclicbarrier-循环栅栏","children":[]},{"level":2,"title":"3. Semaphore 信号灯","slug":"_3-semaphore-信号灯","link":"#_3-semaphore-信号灯","children":[]}],"git":{"createdTime":1713751134000,"updatedTime":1713751134000,"contributors":[{"name":"dongzhaohe","email":"dongzhaohe@credamo.com","commits":1}]},"readingTime":{"minutes":6.08,"words":1825},"filePathRelative":"blog/old/language/java/JUC.md","localizedDate":"2020年1月1日","excerpt":"<h1> 1. 概念</h1>\\n<ul>\\n<li>JUC: java.utl.concrrent</li>\\n<li>进程和线程</li>\\n<li>wait和sleep</li>\\n<li>并发和并行</li>\\n<li>管程\\n<ul>\\n<li>Monitor监视器，也称锁，是一种同步机制，保证同一时间，只有一个线程访问被保护数据或代码</li>\\n<li>JVM同步资源的进入和退出，是用管程对象实现的</li>\\n</ul>\\n</li>\\n<li>用户线程和守护线程：\\n<ul>\\n<li>自定义线程，</li>\\n<li>后台的线程，比如垃圾回收</li>\\n<li>主线程结束，自定义线程仍在，如果没有用户线程，只有守护线程，JVM结束</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
