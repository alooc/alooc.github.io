import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as l,b as e}from"./app-b0773e9a.js";const r={},h=e(`<h1 id="一、排序算法" tabindex="-1"><a class="header-anchor" href="#一、排序算法" aria-hidden="true">#</a> 一、排序算法</h1><h2 id="选择性排序" tabindex="-1"><a class="header-anchor" href="#选择性排序" aria-hidden="true">#</a> 选择性排序：</h2><p><code>对[0.....n-1] 长度为n的数组排序</code></p><h3 id="_1-选择排序" tabindex="-1"><a class="header-anchor" href="#_1-选择排序" aria-hidden="true">#</a> 1. 选择排序</h3><ul><li>从0开始遍历数组： <ul><li>后面位置依次与当前位置比较 <ul><li>小于当前位置的交换</li></ul></li></ul></li><li>遍历结束，排序结束</li></ul><p><strong>O(n²)</strong></p><p><strong>O(1)</strong></p><p><strong>不稳定</strong></p><h3 id="_2-冒泡排序" tabindex="-1"><a class="header-anchor" href="#_2-冒泡排序" aria-hidden="true">#</a> 2. 冒泡排序</h3><ul><li>每次遍历确定最后一位置的数据顺序 <ul><li>遍历过程相邻两个比较 <ul><li>大的后移</li></ul></li></ul></li></ul><p><strong>O(n²)</strong></p><p><strong>O(1)</strong></p><p><strong>稳定</strong></p><h3 id="_3-插入排序" tabindex="-1"><a class="header-anchor" href="#_3-插入排序" aria-hidden="true">#</a> 3. 插入排序</h3><ul><li>每次遍历保证0到当前位置有序 <ul><li>新位置与有序位置的最后位置比较 <ul><li>小的交换</li></ul></li></ul></li></ul><p><strong>O(n²)</strong></p><p><strong>O(1)</strong></p><p><strong>稳定</strong></p><h3 id="_4-归并排序" tabindex="-1"><a class="header-anchor" href="#_4-归并排序" aria-hidden="true">#</a> 4. 归并排序</h3><ul><li>递归处理 <ul><li>每次二分，合并左右两部分 <ul><li>依次比较左右 <ul><li>小的等于的先放入辅助数组，然后++</li><li>一边遍历完后，另一边直接复制</li></ul></li></ul></li></ul></li></ul><p><strong>O(nlogn)</strong></p><p><strong>O(n)</strong></p><p><strong>稳定</strong></p><h3 id="_5-快速排序" tabindex="-1"><a class="header-anchor" href="#_5-快速排序" aria-hidden="true">#</a> 5. 快速排序</h3><ul><li>随机选择一个数作为参照，将其与最后一个交换 <ul><li>小于参照的放左边，等于参照在中间，大于参照放右边</li><li>得到小于区，等于区，大于区，拿等于区边界[l,r]来标识 <ul><li>等于区域的数据已经排好序</li><li>小于、大于部分做递归处理，主要进行分区操作： <ul><li>与标准比较： <ul><li>小于： 与小区区域下一个数据交换，小于区右扩一</li><li>等于：不动，当前位置右移一</li><li>大于：与大于区域前一个数据交换，大于区左扩一</li></ul></li><li>最后，最后一个参考数与大于区的第一个数交换，大于区左边界右移一</li></ul></li></ul></li></ul></li></ul><p><strong>O(nlogn)</strong></p><p><strong>O(logn)</strong></p><p><strong>不稳定</strong></p><h3 id="_6-堆排序" tabindex="-1"><a class="header-anchor" href="#_6-堆排序" aria-hidden="true">#</a> 6. 堆排序</h3><blockquote><p>堆的两种操作：</p><ul><li>插入： 向堆中插入一个数据，当前数据与其父节点比较调整，保持最大堆推结构。<code>向上调整</code> O(logn)</li><li>堆化：随便一个堆，通过对当前节点与其子节点的比较调整，保持子树的最大堆结构。<code>向下调整</code> O(logn)</li></ul></blockquote><ul><li><p>数组放入大根堆</p></li><li><p>依次取出根节点，从后往前排序，取出后调整堆，使其保持最大堆结构</p></li></ul><h2 id="基于桶的排序" tabindex="-1"><a class="header-anchor" href="#基于桶的排序" aria-hidden="true">#</a> 基于桶的排序</h2><p><code>定义适当的桶，数组放入符合的桶中，然后根据规则取出桶中的数据即可排序</code></p><p><code>不基于比较的排序都是根据数据状况来定制，没有选择性排序的通用性</code></p><h3 id="_1-计数排序" tabindex="-1"><a class="header-anchor" href="#_1-计数排序" aria-hidden="true">#</a> 1. 计数排序</h3><p>词频统计，遍历数组后，词频数组保存个数，根据词频数组还原数组后得到排序后的数组</p><h3 id="_2-基数排序" tabindex="-1"><a class="header-anchor" href="#_2-基数排序" aria-hidden="true">#</a> 2. 基数排序</h3><ul><li>准备0-9十个桶，桶多为队列结构</li><li>从低位到高位遍历： <ul><li>个位：进桶，出桶，得到新顺序数组</li><li>十位：新数组基础上，进桶，出桶</li><li>......</li><li>N位</li></ul></li></ul><h1 id="二、-链表" tabindex="-1"><a class="header-anchor" href="#二、-链表" aria-hidden="true">#</a> 二、 链表</h1><h2 id="常见问题总结" tabindex="-1"><a class="header-anchor" href="#常见问题总结" aria-hidden="true">#</a> 常见问题总结：</h2><ol><li><p>逆向链表</p></li><li><p>打印两个链表的公共部分</p></li><li><p>判断一个链表是否为回文结构</p></li><li><p>对链表根据某数分区</p></li><li><p>链表节点含有随机指针，复制该链表</p></li><li><p>两链表相交，求相交的第一个节点：</p><ul><li>判断链表是否有环</li><li>有环，求入环节点</li></ul></li></ol><h1 id="三、树" tabindex="-1"><a class="header-anchor" href="#三、树" aria-hidden="true">#</a> 三、树</h1><h2 id="树的常见分类" tabindex="-1"><a class="header-anchor" href="#树的常见分类" aria-hidden="true">#</a> 树的常见分类：</h2><pre><code>### 完全二叉树
</code></pre><h3 id="满二叉树" tabindex="-1"><a class="header-anchor" href="#满二叉树" aria-hidden="true">#</a> 满二叉树</h3><h3 id="二叉搜索树" tabindex="-1"><a class="header-anchor" href="#二叉搜索树" aria-hidden="true">#</a> 二叉搜索树</h3><h3 id="平衡二叉树" tabindex="-1"><a class="header-anchor" href="#平衡二叉树" aria-hidden="true">#</a> 平衡二叉树</h3><h1 id="四、图" tabindex="-1"><a class="header-anchor" href="#四、图" aria-hidden="true">#</a> 四、图</h1><h2 id="图的表示" tabindex="-1"><a class="header-anchor" href="#图的表示" aria-hidden="true">#</a> 图的表示</h2>`,49),d=[h];function n(t,o){return a(),l("div",null,d)}const c=i(r,[["render",n],["__file","算法总结.html.vue"]]);export{c as default};
