import{_ as a,c as i,o as e,ag as o}from"./chunks/framework.DPDPlp3K.js";const u=JSON.parse('{"title":"1. 架构","description":"","frontmatter":{},"headers":[],"relativePath":"notes/basics/database/rdb/mysql/index.md","filePath":"notes/basics/database/rdb/mysql/index.md"}'),p={name:"notes/basics/database/rdb/mysql/index.md"};function t(r,l,s,n,h,c){return e(),i("div",null,l[0]||(l[0]=[o(`<h1 id="_1-架构" tabindex="-1">1. 架构 <a class="header-anchor" href="#_1-架构" aria-label="Permalink to &quot;1. 架构&quot;">​</a></h1><blockquote><ul><li><p>mysql的整体架构</p></li><li><p>innodb引擎原理</p><ul><li>buffer pool <ul><li>三大链表</li></ul></li><li>ahi</li><li>双写机制</li><li>事务的实现 <ul><li>事务问题</li><li>acid的解决</li></ul></li><li>数据读、写流程</li></ul></li></ul></blockquote><h2 id="_1-1-整体架构" tabindex="-1">1.1 整体架构 <a class="header-anchor" href="#_1-1-整体架构" aria-label="Permalink to &quot;1.1 整体架构&quot;">​</a></h2><p><img src="https://raw.githubusercontent.com/alooc/images/main/blog/image-20250726234655219.png" alt=""></p><p>mysql整体可分为三部分，sql server层、存储引擎层、磁盘数据目录层</p><p>server层：</p><ol><li>用户与server层的连接池建立连接，开始使用。</li><li>调用sql接口，处理sql</li><li>先对sql进行缓存查询，缓存中没有时才开始sql解析</li><li>解析器，解析成ast</li><li>优化器，优化sql，选择出一条成本最低的执行计划</li><li>然后执行sql</li></ol><p>innodb存储引擎层：</p><ol><li>所有可操作数据页放在buffer pool中，三大链表辅助管理</li><li>ahx，自动为热点数据建立hash索引，提高读写效率</li><li>redo binlog日志 双写缓冲区，防止数据丢失</li><li>undo日志和readview, 实现mvcc，让事务数据只对当前版本可见</li></ol><p>磁盘层：</p><pre><code>1. 表空间，不同的表空间类型：
 	1. 系统表空间
     	1. 双写缓冲区
 	2. 临时表空间
 	3. 通用表空间
 	4. 独立表空间
 	5. undo 日志
 	6. redo 日志
 	7. binlog日志
2. 数据以页存储
 	1. 1页16K, 64页为1区，1区1M，往上根据不同类型分段
</code></pre><h2 id="_1-2-innodb引擎原理" tabindex="-1">1.2 innodb引擎原理 <a class="header-anchor" href="#_1-2-innodb引擎原理" aria-label="Permalink to &quot;1.2 innodb引擎原理&quot;">​</a></h2><p><img src="https://raw.githubusercontent.com/alooc/images/main/blog/image-20250726182105649.png" alt=""></p><h3 id="_1-buffer-pool" tabindex="-1">1. buffer pool <a class="header-anchor" href="#_1-buffer-pool" aria-label="Permalink to &quot;1.  buffer pool&quot;">​</a></h3><p>磁盘的数据加载到buffer pool上操作。</p><p>三大链表辅助：</p><pre><code>1. free list: 记录buffer pool上空闲页，插入时分配页
1. lru list: 维护buffer pool的页，是分代模型，young区放热点数据，old区进行新数据进入、旧数据删除、选择新数据进入young区
1. flush list：维护被修改的脏页，双写机制中，第二次写时，刷到磁盘
</code></pre><h3 id="_2-ahi" tabindex="-1">2. AHI <a class="header-anchor" href="#_2-ahi" aria-label="Permalink to &quot;2. AHI&quot;">​</a></h3><p>adaptive hash index</p><p>自适应哈希索引</p><p>自动为b+索引中的热点数据建立hash索引，是存储在内存中的</p><h3 id="_3-双写机制" tabindex="-1">3. 双写机制 <a class="header-anchor" href="#_3-双写机制" aria-label="Permalink to &quot;3. 双写机制&quot;">​</a></h3><p>redo日志，是在数据页级别上的日志。如果页损坏了，就不能恢复。所以需要双写缓冲区。</p><p>另外，双写机制是在wal机制运行之后的。</p><p>双写：</p><p>​ 第一次： 脏页 -&gt; 内存中的双写缓冲区 -&gt; os buffer -&gt; 磁盘的双写缓冲区（可以在系统表空间，也可设置参数指定文件）</p><p>​ 第二次： 脏页 -&gt; os buffer -&gt; 磁盘上的真实数据位置</p><h3 id="_4-事务实现的原理" tabindex="-1">4. 事务实现的原理 <a class="header-anchor" href="#_4-事务实现的原理" aria-label="Permalink to &quot;4. 事务实现的原理&quot;">​</a></h3><ol><li>事务问题：</li></ol><p>​ 脏读：读到未提交事务的数据</p><p>​ 不可重复读： 两次重复select，会被其他事务的修改影响，查询结果不同</p><p>​ 幻读：两次重复查询，第一次没数据，第二次因为新数据的插入，读到了新的数据。</p><ol start="2"><li>事务的隔离级别：</li></ol><p>​ 未提交读： 存在脏读</p><p>​ 提交读： 存在不可重复读、幻读。此级别的select readview是每次查询都会常见一个，也没有间歇锁</p><p>​ 可重复读： 无3种问题。快照读在第一次select时就创建，无论是否有数据都会创建。select... for update 只锁住了当前行，使用间歇锁解决幻读问题。</p><p>​ 序列化： 所有事务串行</p><ol start="3"><li><p>事务的实现原理</p><p>原子性：</p><p>​ 同一事务要么全部成功，要么全部失败。</p><p>​ 实现思路: 提供回滚机制。</p><p>​ 实现： undo日志实现</p></li></ol><p><img src="https://raw.githubusercontent.com/alooc/images/main/blog/image-20250726182450125.png" alt=""></p><p>​ 隔离性：</p><p>​ 不同事务之间相互隔离</p><p>​ 实现思路： mvcc</p><p>​ 实现： readview + undo构建对应版本的数据</p><p><img src="https://raw.githubusercontent.com/alooc/images/main/blog/image-20250726182247813.png" alt=""></p><p>​ 持久性：</p><p>​ 数据持久化</p><p>​ 实现： redo日志， binlog日志</p><p>​ <img src="https://raw.githubusercontent.com/alooc/images/main/blog/image-20250726182300517.png" alt=""></p><p>​ 一致性：以上因素共同作用的结果</p><h3 id="_5-数据读写流程" tabindex="-1">5. 数据读写流程 <a class="header-anchor" href="#_5-数据读写流程" aria-label="Permalink to &quot;5. 数据读写流程&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/alooc/images/main/blog/image-20250726181936438.png" alt=""></p><h1 id="_2-调优" tabindex="-1">2. 调优 <a class="header-anchor" href="#_2-调优" aria-label="Permalink to &quot;2. 调优&quot;">​</a></h1><h2 id="_2-1-索引" tabindex="-1">2.1 索引 <a class="header-anchor" href="#_2-1-索引" aria-label="Permalink to &quot;2.1 索引&quot;">​</a></h2><ol><li>分类：</li></ol><ul><li><p>聚集索引</p></li><li><p>二级索引</p></li></ul><ol start="2"><li><p>联合索引很重要</p><p>最左匹配原则</p><p>精确匹配+ 范围匹配， 范围匹配后的索引字段失效</p></li></ol><p><img src="https://raw.githubusercontent.com/alooc/images/main/blog/image-20250726182155221.png" alt=""></p><p><img src="https://raw.githubusercontent.com/alooc/images/main/blog/image-20250726182223800.png" alt=""></p><h2 id="_2-2-监控" tabindex="-1">2.2 监控 <a class="header-anchor" href="#_2-2-监控" aria-label="Permalink to &quot;2.2 监控&quot;">​</a></h2><blockquote><p>无监控不调优</p></blockquote><ol><li><p>查看执行成本</p><p>set profiling =1;</p><p>show profiles;</p></li><li><p>performace_shcema数据库</p></li><li><p>show processlist</p></li><li><p>explain</p></li><li><p>show status like &#39;Handler_read%&#39;; 数据库索引整体使用情况分析</p></li><li><p>慢查询</p><ol><li>show variables like &#39;%slow_query_log%&#39;;</li><li>set global slow_query_log=&#39;ON&#39;;</li><li>show variables like &#39;%long_query_time%&#39;;</li><li>set global long_query_time = 1 ;</li><li>show global variables like &#39; %long_query_time% &#39;;</li><li>mysqldumpslow -s t -t 5 /var/lib/mysql/demo01-slow.log <ol><li>-s sort -t top</li></ol></li></ol></li></ol><h2 id="_2-3-调优" tabindex="-1">2.3 调优 <a class="header-anchor" href="#_2-3-调优" aria-label="Permalink to &quot;2.3 调优&quot;">​</a></h2><ol><li><p>防止索引失效</p><p>索引字段使用表达式、类型转换</p><p>不符合最左匹配， like， 条件字段的顺序，orderby 的字段顺序</p><p>范围匹配之后的索引字段失效</p><p>or 不都是索引列</p><p>null</p><ol start="2"><li><p>优化sql</p><p>limit</p><p>子查询</p><p>​ join优化</p><p>​ 子查询结果集很大用exists 不用in</p><p>union 如果不加all，去重的成本有时是很高的</p></li></ol></li></ol><h1 id="_3-集群" tabindex="-1">3. 集群 <a class="header-anchor" href="#_3-集群" aria-label="Permalink to &quot;3. 集群&quot;">​</a></h1>`,64)]))}const b=a(p,[["render",t]]);export{u as __pageData,b as default};
