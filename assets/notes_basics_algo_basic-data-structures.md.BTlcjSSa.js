import{_ as l,c as i,o as e,ag as r}from"./chunks/framework.DPDPlp3K.js";const b=JSON.parse('{"title":"基础数据结构","description":"","frontmatter":{"title":"基础数据结构","date":"2024-09-19 18:26","categories":["算法"],"tags":"算法","sidebar":"heading"},"headers":[],"relativePath":"notes/basics/algo/basic-data-structures.md","filePath":"notes/basics/algo/basic-data-structures.md"}'),t={name:"notes/basics/algo/basic-data-structures.md"};function h(o,a,n,u,d,s){return e(),i("div",null,a[0]||(a[0]=[r('<h1 id="_1-基础数据结构概述" tabindex="-1">1. 基础数据结构概述 <a class="header-anchor" href="#_1-基础数据结构概述" aria-label="Permalink to &quot;1. 基础数据结构概述&quot;">​</a></h1><ul><li>数组</li><li>链表</li><li>栈</li><li>队列</li><li>堆、加强堆</li><li>树 <ul><li>二叉树</li><li>完全二叉树</li><li>搜索二叉树</li><li>平衡二叉树</li></ul></li><li>并查集</li><li>图</li><li>滑动窗口</li><li>单调栈</li><li>哈希表</li><li>有序表</li><li>红黑树</li></ul><h1 id="_2-基础数据结构详解" tabindex="-1">2. 基础数据结构详解 <a class="header-anchor" href="#_2-基础数据结构详解" aria-label="Permalink to &quot;2. 基础数据结构详解&quot;">​</a></h1><h2 id="_1-数组" tabindex="-1">1. 数组 <a class="header-anchor" href="#_1-数组" aria-label="Permalink to &quot;1. 数组&quot;">​</a></h2><h2 id="_2-链表" tabindex="-1">2. 链表 <a class="header-anchor" href="#_2-链表" aria-label="Permalink to &quot;2. 链表&quot;">​</a></h2><h3 id="概念" tabindex="-1">概念： <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念：&quot;">​</a></h3><ul><li>单向链表</li><li>双向链表</li></ul><h3 id="相关算法" tabindex="-1">相关算法： <a class="header-anchor" href="#相关算法" aria-label="Permalink to &quot;相关算法：&quot;">​</a></h3><ul><li>反转单链表和双链表</li><li>删除给定值</li><li>快慢指针</li><li>使用容器</li></ul><h2 id="_3-栈" tabindex="-1">3. 栈 <a class="header-anchor" href="#_3-栈" aria-label="Permalink to &quot;3. 栈&quot;">​</a></h2><h3 id="相关算法-1" tabindex="-1">相关算法： <a class="header-anchor" href="#相关算法-1" aria-label="Permalink to &quot;相关算法：&quot;">​</a></h3><ul><li>使用数组和双向链表实现</li><li>实现特殊的栈，实现返回栈中最小元素的功能 O(1) push pop getMin</li></ul><h2 id="_4-队列" tabindex="-1">4. 队列 <a class="header-anchor" href="#_4-队列" aria-label="Permalink to &quot;4. 队列&quot;">​</a></h2><h3 id="相关算法-2" tabindex="-1">相关算法： <a class="header-anchor" href="#相关算法-2" aria-label="Permalink to &quot;相关算法：&quot;">​</a></h3><ul><li>使用数组和双向链表实现</li></ul><h2 id="_5-堆" tabindex="-1">5. 堆 <a class="header-anchor" href="#_5-堆" aria-label="Permalink to &quot;5. 堆&quot;">​</a></h2><h3 id="概念-1" tabindex="-1">概念： <a class="header-anchor" href="#概念-1" aria-label="Permalink to &quot;概念：&quot;">​</a></h3><p>堆是完全二叉树</p><h3 id="相关算法-3" tabindex="-1">相关算法： <a class="header-anchor" href="#相关算法-3" aria-label="Permalink to &quot;相关算法：&quot;">​</a></h3><ul><li>heapinsert和heapify</li></ul><h2 id="_6-树" tabindex="-1">6. 树 <a class="header-anchor" href="#_6-树" aria-label="Permalink to &quot;6. 树&quot;">​</a></h2><h3 id="概念-2" tabindex="-1">概念： <a class="header-anchor" href="#概念-2" aria-label="Permalink to &quot;概念：&quot;">​</a></h3><ul><li>二叉树</li><li>完全二叉树：除最后一层外所有层的都是满的，且最后一层由左向右排列，可以不满，但不能有空位。</li><li>搜索二叉树：头节点的值大于左子节点，小于右子节点</li><li>平衡二叉树：所有节点的左右子树高度差不超过1</li></ul><h3 id="相关算法-4" tabindex="-1">相关算法： <a class="header-anchor" href="#相关算法-4" aria-label="Permalink to &quot;相关算法：&quot;">​</a></h3><ul><li>树形DP问题</li><li>前、中、后序遍历，递归序</li><li>判断二叉树是否是完全二叉树、搜索二叉树、平衡二叉树</li></ul><h2 id="_7-并查集" tabindex="-1">7. 并查集 <a class="header-anchor" href="#_7-并查集" aria-label="Permalink to &quot;7. 并查集&quot;">​</a></h2><h3 id="概念-3" tabindex="-1">概念： <a class="header-anchor" href="#概念-3" aria-label="Permalink to &quot;概念：&quot;">​</a></h3><ul><li>支持合并和查询的集合结构</li></ul><h3 id="相关算法-5" tabindex="-1">相关算法： <a class="header-anchor" href="#相关算法-5" aria-label="Permalink to &quot;相关算法：&quot;">​</a></h3><ul><li>并查集实现</li><li>并查集的应用</li></ul><h2 id="_8-图" tabindex="-1">8. 图 <a class="header-anchor" href="#_8-图" aria-label="Permalink to &quot;8. 图&quot;">​</a></h2><h3 id="相关算法-6" tabindex="-1">相关算法： <a class="header-anchor" href="#相关算法-6" aria-label="Permalink to &quot;相关算法：&quot;">​</a></h3><ul><li>图的实现</li><li>宽度优先遍历和深度优先遍历</li><li>两个最小生成树算法</li><li>拓扑排序</li></ul><h2 id="_9-滑动窗口" tabindex="-1">9. 滑动窗口 <a class="header-anchor" href="#_9-滑动窗口" aria-label="Permalink to &quot;9. 滑动窗口&quot;">​</a></h2><h3 id="概念-4" tabindex="-1">概念： <a class="header-anchor" href="#概念-4" aria-label="Permalink to &quot;概念：&quot;">​</a></h3><ul><li>滑动窗口是一种想象出来的数据结构，有左边界L和右边界R <ul><li>在数组或者字符串或者一个序列上，记为S，窗口就是S[L...R]这一部分</li><li>L往右滑意味着一个样本出了窗口，R往右滑意味着一个样本进了窗口</li><li>L和R都只能往右滑</li></ul></li></ul><h3 id="相关算法-7" tabindex="-1">相关算法： <a class="header-anchor" href="#相关算法-7" aria-label="Permalink to &quot;相关算法：&quot;">​</a></h3><ul><li>滑动窗口相关问题</li></ul><h2 id="_10-单调栈" tabindex="-1">10. 单调栈 <a class="header-anchor" href="#_10-单调栈" aria-label="Permalink to &quot;10. 单调栈&quot;">​</a></h2><h3 id="概念-5" tabindex="-1">概念： <a class="header-anchor" href="#概念-5" aria-label="Permalink to &quot;概念：&quot;">​</a></h3><ul><li>准备一个栈，栈底往上由小到大 <ul><li>数组压栈时，小于栈顶，栈顶弹出，栈顶元素形成信息： <ul><li>此时，栈下面的是左边离它距离近且小的值，数组的数是其右边离它近且小的值</li></ul></li></ul></li></ul><h3 id="相关算法-8" tabindex="-1">相关算法： <a class="header-anchor" href="#相关算法-8" aria-label="Permalink to &quot;相关算法：&quot;">​</a></h3><ul><li>单调栈的实现</li><li>单调栈相关问题</li></ul><h2 id="_11-哈希表" tabindex="-1">11. 哈希表 <a class="header-anchor" href="#_11-哈希表" aria-label="Permalink to &quot;11. 哈希表&quot;">​</a></h2><h2 id="_12-有序表" tabindex="-1">12. 有序表 <a class="header-anchor" href="#_12-有序表" aria-label="Permalink to &quot;12. 有序表&quot;">​</a></h2><h2 id="_13-红黑树" tabindex="-1">13. 红黑树 <a class="header-anchor" href="#_13-红黑树" aria-label="Permalink to &quot;13. 红黑树&quot;">​</a></h2>',46)]))}const q=l(t,[["render",h]]);export{b as __pageData,q as default};
