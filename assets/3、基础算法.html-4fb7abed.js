const t=JSON.parse('{"key":"v-013fe386","path":"/blog/algorithm/base/3%E3%80%81%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.html","title":"2、基础算法","lang":"zh-CN","frontmatter":{"title":"2、基础算法","sidebar":"heading","category":["算法"],"tag":"算法","description":"左神NB 1. 贪心算法 1、最自然智慧的算法 2、用一种局部最功利的标准，总是做出在当前看来最好的选择 3、难点在于证明局部最功利的标准可以得到全局最优解 4、对于贪心算法的学习主要以增加阅历为主 2. 暴力递归 暴力递归就是尝试 1、把问题转换为规模缩小了的同类问题的子问题 2、有明确的不需要继续进行递归的条件（base case) 3、有当得到了子问题的结果之后的决策过程 4、不记录每一个子问题的解","head":[["meta",{"property":"og:url","content":"https://alooc.github.io/blog/algorithm/base/3%E3%80%81%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Alooc"}],["meta",{"property":"og:title","content":"2、基础算法"}],["meta",{"property":"og:description","content":"左神NB 1. 贪心算法 1、最自然智慧的算法 2、用一种局部最功利的标准，总是做出在当前看来最好的选择 3、难点在于证明局部最功利的标准可以得到全局最优解 4、对于贪心算法的学习主要以增加阅历为主 2. 暴力递归 暴力递归就是尝试 1、把问题转换为规模缩小了的同类问题的子问题 2、有明确的不需要继续进行递归的条件（base case) 3、有当得到了子问题的结果之后的决策过程 4、不记录每一个子问题的解"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-10-21T10:11:16.000Z"}],["meta",{"property":"article:author","content":"Alooc"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:modified_time","content":"2024-10-21T10:11:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2、基础算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-10-21T10:11:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Alooc\\",\\"url\\":\\"https://alooc.github.io\\"}]}"]]},"headers":[],"git":{"createdTime":1726848920000,"updatedTime":1729505476000,"contributors":[{"name":"alooc","email":"zbsx508@gmail.com","commits":3}]},"readingTime":{"minutes":7.75,"words":2324},"filePathRelative":"blog/algorithm/base/3、基础算法.md","localizedDate":"2024年9月20日","excerpt":"<blockquote>\\n<p>左神NB</p>\\n</blockquote>\\n<h1> 1. 贪心算法</h1>\\n<ul>\\n<li>1、最自然智慧的算法</li>\\n<li>2、用一种局部最功利的标准，总是做出在当前看来最好的选择</li>\\n<li>3、难点在于证明局部最功利的标准可以得到全局最优解</li>\\n<li>4、对于贪心算法的学习主要以增加阅历为主</li>\\n</ul>\\n<h1> 2. 暴力递归</h1>\\n<ul>\\n<li>暴力递归就是尝试</li>\\n<li>1、把问题转换为规模缩小了的同类问题的子问题</li>\\n<li>2、有明确的不需要继续进行递归的条件（base case)</li>\\n<li>3、有当得到了子问题的结果之后的决策过程</li>\\n<li>4、不记录每一个子问题的解</li>\\n</ul>","autoDesc":true}');export{t as data};
