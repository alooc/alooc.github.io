import{_ as l}from"./plugin-vue_export-helper-c27b6911.js";import{o as i,c as e,b as r}from"./app-b0773e9a.js";const a={},p=r('<blockquote><p>左神NB</p></blockquote><h1 id="_1-贪心算法" tabindex="-1"><a class="header-anchor" href="#_1-贪心算法" aria-hidden="true">#</a> 1. 贪心算法</h1><ul><li>1、最自然智慧的算法</li><li>2、用一种局部最功利的标准，总是做出在当前看来最好的选择</li><li>3、难点在于证明局部最功利的标准可以得到全局最优解</li><li>4、对于贪心算法的学习主要以增加阅历为主</li></ul><h1 id="_2-暴力递归" tabindex="-1"><a class="header-anchor" href="#_2-暴力递归" aria-hidden="true">#</a> 2. 暴力递归</h1><ul><li>暴力递归就是尝试</li><li>1、把问题转换为规模缩小了的同类问题的子问题</li><li>2、有明确的不需要继续进行递归的条件（base case)</li><li>3、有当得到了子问题的结果之后的决策过程</li><li>4、不记录每一个子问题的解</li></ul><h1 id="_3-动态规划" tabindex="-1"><a class="header-anchor" href="#_3-动态规划" aria-hidden="true">#</a> 3. 动态规划</h1><blockquote><p>从暴力递归到动态规划</p></blockquote><ul><li><p>1、树立常识：</p><ul><li>动态规划是结果，不是原因，动态规划从暴力规划优化而来</li><li>学会尝试是解决动态规划最本质的能力</li></ul></li><li><p>2、技巧：</p><ul><li><p>什么暴力递归可以继续优化？</p><ul><li>有重复调用同一个子问题的解，这种递归可以优化</li></ul></li><li><p>如果每一个子问题都是不同的解，无法优化也不用优化</p></li><li><p>递归优化：分析可变参数的变化范围</p></li><li><p>暴力递归和动态规划的关系：</p><ul><li>某一个暴力递归，有解的重复调用，就可以把这个暴力递归优化成动态规划<br> 任何动态规划问题，都一定对应着某一个有重复过程的暴力递归<br> 但不是所有的暴力递归，都一定对应着动态规划</li></ul></li><li><p>面试题和动态规划的关系</p><ul><li>解决一个问题，可能有很多尝试方法<br> 可能在很多尝试方法中，又有若干个尝试方法有动态规划的方式<br> 一个问题可能有若干种动态规划的解法</li></ul></li><li><p>如何找到某个问题的动态规划方式？</p><ul><li>1）设计暴力递归：重要原则+4种常见尝试模型！重点！</li></ul></li><li><p>2）分析有没有重复解：套路解决</p></li><li><p>3）用记忆化搜索-&gt;用严格表结构实现动态规划：套路解决</p></li><li><p>4）看看能否继续优化：套路解决</p></li><li><p>面试中设计暴力递归过程的原则：<br> 1）每一个可变参数的类型，一定不要比int类型更加复杂<br> 2）原则1)可以违反，让类型突破到一维线性结构，那必须是单一可变参数<br> 3）如果发现原则1)被违反，但不违反原则2),只需要做到记忆化搜索即可<br> 4）可变参数的个数，能少则少</p></li><li><p>知道了面试中设计暴力递归过程的原则，然后呢？</p><ul><li>一定要逼自己找到不违反原则情况下的暴力尝试！<br> 如果你找到的暴力尝试，不符合原则，马上舍弃！找新的！<br> 如果某个题目突破了设计原则，一定极难极难，面试中出现概率低于5%!</li></ul></li></ul></li><li><p>3、模型：</p><ul><li>常见的4种尝试模型 <ol><li>从左往右的尝试模型 从左往右进行可能性分析</li><li>范围上的尝试模型 从L 到R的某个范围上进行分析</li><li>多样本位置全对应的尝试模型 对多样本的最后一个位置进行可能性分析</li><li>寻找业务限制的尝试模型 业务范围分析</li></ol></li><li>如何分析有没有重复解：<br> 列出调用过程，可以只列出前几层<br> 有没有重复解，一看便知</li><li>暴力递归到动态规划的套路： <ol><li>你已经有了一个不违反原则的暴力递归，而且的确存在解的重复调用</li><li>找到哪些参数的变化会影响返回值，对每一个列出变化范围</li><li>参数间的所有的组合数量，意味着表大小</li><li>记忆化搜索的方法就是傻缓存，非常容易得到</li><li>规定好严格表的大小，分析位置的依赖顺序，然后从基础填写到最终解</li><li>对于有枚举行为的决策过程，进一步优化**</li></ol></li><li>动态规划的进一步优化 <ol><li>空间压缩</li><li>状态化简</li><li>四边形不等式</li><li>其他优化技巧</li></ol></li></ul></li></ul>',8),o=[p];function u(t,c){return i(),e("div",null,o)}const n=l(a,[["render",u],["__file","3、基础算法.html.vue"]]);export{n as default};
